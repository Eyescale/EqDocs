#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developers: Packet Handling

#include "header.shtml"

<h2>Packet Handling</h2>
<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
</p>

<h3>Background</h3>
<p>
  The packet handling code in Equalizer is the core piece of the networking
  layer. This document describes the packet dispatch mechanism used by the
  Equalizer network layer (<code>namespace eqNet</code>). The implementation
  matches this document at the time of writing (UPDATE), but may diverge over
  time.
</p><p>
  <img src="documents/design/packets.png" 
       alt="Flow chart of the eqNet packet handling"/>
</p>

<h3>Packets</h3>
<p>
  <code>Packet</code>s are the base piece of information exchanged
  between <code>Node</code>s. A packet has a data type to identify the object it
  is addressed to, and a command number to identify the purpose of the
  packet. Packets contain additional data depending on the data type and
  command, as explained below.
</p>
<h3>Nodes</h3>
<p>
  <code>Node</code>s are the basic entity in the network layer. They communicate
  with each other using <code>Connection</code>s. During initialization, a node
  typically opens a listening connection, and starts the receiver thread. The
  receiver thread listens on all connections of the node. When a new node
  connects, he calls <code>handleConnect</code>, which accepts the connection,
  creates a new Node and adds this connected node to the set of
  connections. Nodes send each other <code>Packet</code>s. The receiving node
  reads the packet from the connection and calls <code>dispatchPacket</code>.
</p>
<h3>The eqNet Base Class</h3>
<p>
  <code>eqNet::Base</code> provides packet dispatching using a command handler
  table. During construction, sub classes provide command handlers for each
  command using <code>registerCommand</code>. The method
  <code>handleCommand</code> calls the registered command handler for the
  provided packet. The command handler may return one of the following command
  result codes, which is returned by <code>handleCommand</code>:
  <dl>
    <dt>COMMAND_HANDLED</dt><dd>The command was handled correctly.</dd>
    <dt>COMMAND_REDISPATCH</dt><dd>The command can not be handled at the moment,
      and should be redispatched later. </dd>
    <dt>COMMAND_PUSH</dt><dd>The command can not be handled from the command
      handler, and should be pushed to another entity, typically to another
      thread.</dd>
    <dt>COMMAND_PUSH_FRONT</dt><dd>Like COMMAND_PUSH, except that the command
      has a high priority, e.g., it bypasses other commands queued for execution
      by another thread.</dd>
    <dt>COMMAND_ERROR</dt><dd>A critical error occured during command
        processing.</dd>
  </dl>
</p>
<h3>Node Packet Dispatch</h3>
<p>
  Depending on the packet's data type, <code>dispatchPacket</code> decides how
  the packet is handled. For node packets, <code>handleCommand</code> is
  called. The result is handled accordingly, that is, COMMAND_REDISPATCH causes
  the packet to be added to the list of redispatch packets, and for COMMAND_PUSH
  and COMMAND_PUSH_FRONT <code>pushCommand</code> or
  <code>pushCommandFront</code> is called, respectively. For 
  <code>Session</code> and <code>Object</code> packets, 
  <code>Session::dispatchPacket</code> is invoked. The session is identified by
  the sessionID contained in the <code>SessionPacket</code>. For all other data
  types, <code>handlePacket</code> is called.
</p><p>
  Any command handler called directly or indirectly
  from <code>dispatchPacket</code> is not allowed to block, since it is executed
  from within the receiver thread and would therefore block the packet handling.
</p>
<h3>Session Packet Dispatch</h3>
<p>
  The <code>Session</code> inherits, like the node, from 
  <code>eqNet::Base</code>. The session dispatch works similar to the node
  dispatch. For session packets, <code>handleCommand</code> is called, and the
  result is returned to the node, which handles it accordingly. For object
  packets, <code>Object::handleCommand</code> is called and the result is
  returned. The object is retrieved using the objectID, and possibly instanceID,
  contained in the <code>ObjectPacket</code>.
</p>
<h3>Asynchronous Handling of Packets</h3>
<p>
  Several commands for Equalizer entities, for example window initialisation
  requests, have to be handled by another thread. A
  thread-safe <code>RequestQueue</code> is used to transfer the packet from the
  receiver to the consumer thread. This is either done by a special command
  handler, or by overriding <code>Node::pushCommand</code>
  or <code>Node::pushCommandFront</code>, depending on the object, command and
  destination thread.
</p>

#include "footer.shtml"
