#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developers: Frames

#include "header.shtml"

<h2>Compound Frame Handling</h2>
<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
</p>

<ul>
  <li><a href="documents/design/frames.html#Background">Background</a></li>
  <li><a href="documents/design/frames.html#Overview">Overview</a></li>
  <li><a href="documents/design/frames.html#Requirements">Requirements</a></li>
  <li><a href="documents/design/frames.html#Implementation">Implementation</a></li>
  <li><a href="documents/design/frames.html#Restrictions">Restrictions</a></li>
  <li><a href="documents/design/frames.html#FileFormat">File Format</a></li>
</ul>

<a name="Background"/>
<h3>Background</h3>
<p>
  Frames are used by <a href="documents/design/compounds.html">compounds</a>
  during the recomposition phase. This document discusses the implementation
  details of this part of the compound spec.
</p>

<a name="Overview"/>
<h3>Overview</h3>
<p>
  <img src="documents/design/frames.png" 
       alt="UML diagram of compound frames"/>
</p><p>
  Frames can be input frames or output frames. Output frames produce the data
  consumed by input frames. The common link between the output and input
  frames is the frame buffer. A frame buffer holds the data, which is
  organized into a set of images for each (OpenGL) framebuffer attachment -
  color, depth and stencil. Each image represents a 2D array of
  pixels. Typically one image per type is used.
</p><p>
  A frame has a format, which defines which components of the framebuffer are to
  be read back (output frame) or assembled (input frames). It has a viewport,
  which defines the fractional portion of the channel has to be read back
  (output) or which fractional portion of the corresponding output frame (input
  frames) has to be assembled.
</p>
  

<a name="Requirements"/>
<h3>Requirements</h3>
<p>
 Frames are used in the following way:
 <ul>
  <li>Output images for one output frame are produced by a single node.</li>
  <li>Output images are send to multiple nodes, where the input frames are.</li>
  <li>The input frame format may be a subset of the output frame
    format. Consequently, the node producing the output images only sends images
    to nodes if the input frame format matches.</li>
  <li>Same optimisation for other attributes, i.e., viewport, eye(?)</li>
  <li>Frames and images are relatively static during rendering. The objects
    should be reused from (config) frame to frame to avoid costly network
    instanciation.</li>
  <li>It must be possible to select a ready frame from a list of input frames,
    to allow early assembly when using multiple input frames.</li>
  <li>
 </ul>
</p>

<a name="Implementation"/>
<h3>Implementation</h3>
<p>
  On the server:
  <pre>
    Compound::update
        prepare output frames (tree traversal)
           allocate and register frame buffer
           set current data (viewport, format, eye, ...)
           commit frame buffer (new version)
           commit frame
        prepare input frames (2nd tree traversal)     
           set frame buffer from output frame
           set current data (viewport, format, eye, ...)
           commit frame

    Compound::updateChannel (per-channel task generation)
        foreach output frame
            if applicable (filter: format, vp, eye, already send to node)
                send readback task
                    [ output frame id and version ]
                      -> holds frame buffer id and version
                        -> holds frame number
        foreach output frame
            foreach input frame for output frame
                if applicable (filter: format, vp, eye, already send to node)
                    send transmit task
                        [ output frame buffer id and version ]
        send assemble task
            foreach input frame
                add input frame 
  </pre>

  On the "output" node:
  <pre>
    readback task:
        do readback

    transmit task:
        FrameBuffer: 
            foreach matching image
                transmit image packet [ frame number, type, vp, data ]
            transmit frame buffer ready [ frame number ]
  </pre>
    
  On the "input" node:
  <pre>
    assemble task
        foreach input frame
            set frame buffer to not ready
            release old images
            set frame buffer 'version' to config frame number
                moves queues images to current images
                unblocks if current 'version' is ready
        call assemble()
            sync frame[s]
            assemble frame[s]
    [recv thread]
        receive input image
            save into recycled Image object
            if( frame buffer version < image version )
                queue image
            else if( frame buffer version == image version )
                add image to current images
            else ASSERT since not reachable
  </pre>
</p>

<a name="Restrictions"/>
<h3>Restrictions</h3>
<p>
</p>

<a name="FileFormat"/>
<h3>File Format</h3>
 <p>
   See <a href="documents/design/compounds.html#FileFormat">compound spec</a>.
 </p>
       
#include "footer.shtml"
