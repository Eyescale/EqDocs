
                       Decomposition in Equalizer
                       ==========================

                       Author: eilemann@gmail.com
                       Date:   11. July 2006

Background
----------

 OpenGL Multipipe SDK (MPK) used the concept of compounds to describe
 the decomposition and recomposition of the rendering. The compound had
 a mode describing the decomposition algorithm, and various flags to
 modify it. Each compound has a channel, on which the rendering is
 executed. Compounds form a tree. The top-most compound's channel
 defines the view to be rendered by all children.


Requirements
------------

 The following decomposition modes have to be supported:

  [x] Sync mode where all children are synchronized for SwapBuffers
  [x] 2D or screen-space partioning of the destination view 
  [x] DB or database partioning of the destination view 
  [x] Eye decomposition for stereo rendering
  [x] DPlex or time-space decomposition
  [?] Subpixel decompositions (FSAA, DOF)

 The following recomposition modes have to be supported:

  [x] Tile-based recomposition, typically used by 2D, Eye and DPlex
      decompositions
  [x] Z-based recomposition, typically used by DB decompositions
      (polygonal data)
  [x] Ordered alpha-based blending recomposition, typically used by DB
    decompositions (volume data)
  [x] Unordered alpha-based blending recomposition, typically used by
      subpixel decompositions
  [?] HW-based recompositions, typically used by 2D, subpixel, eye and
      DPlex decompositions.
 
 The following optimisation have to be possible:

  [x] Parallelization of the recomposition step, typically across all
      source channels, easily configurable.
  [?] Automatic per-frame adjustments of the decomposition for loadbalancing
  [x] Assembly before and after rendering for transport optimisations
  [x] Assembly on the CPU or GPU (default)
  [x] Configuration of the parts of the framebuffer to be transported
      (color, depth, ...)
  [x] Configuration of the format, type and means used to read and write
      the data. Format/type are the OpenGL format and type. Means can
      be: read/draw pixels, texture transfers, framebuffer attachments,
      copy pixels, ...
  [?] Cross channel loadbalancing

Glossary
--------
  - compound: an ordered collection of tasks for a channel. Can have
    compound children.
  - frame: a collection of images belonging to the same framebuffer (as
    in OpenGL)
  - image: a 2D array of pixels with a type and format, typically
    originating from the color, depth, or stencil buffer.
  - channel: A viewport on a drawable, the basic rendering unit in Equalizer.

Implementation
--------------

 Equalizer uses a compound tree, similar to MPK. In contrast to MPK, the
 decomposition and recomposition is not described using flags. Instead,
 the rendering tasks are directly described for each compound. By
 combining the right tasks, the same functionality as in MPK can be
 achieved. The following config file illustrates the equivalent of a MPK
 2-channel 2D compound:

 compound
 {
     channel "destination"
     wall {} // Frustum descriptions in Equalizer are on the compound

     compound // part rendered by second channel
     {
         channel  "buffer"
         viewport [ .5 0 .5 1 ]
         
         outputframe {}
     }
     compound // part rendered by dest channel
     {
         task     [ CULL DRAW ]
         viewport [ 0 0 .5 1 ] // restrict vp to half
     }

     inputframe { name "frame.buffer" }
 }

 Each compound executes the tasks in the order they appear below. DRAW
 tasks are only executed on leaf compounds. The following tasks are possible:

  - CLEAR: clears the frame buffer. Uses eye and viewport (see below for
    attributes)
  - CULL: Performs view frustum culling. Uses eye, viewport, range,
    input queues and output queues.
    Q: Default input/output queue?
    Q: Other culls, e.g., occlusion?
  - DRAW: Performs rendering. Uses eye, viewport, range and input
    queues.
    Q: Default input queue?
  - <compounds>: This is not a task. The tasks for the direct child
    compounds are executed after CULL (DRAW is not executed on non-leaf
    compounds).
  - READBACK: Reads framebuffer contents. Uses eye, viewport and output
    frames. By default, the task executes the readback unordered and
    potentially pipelined or in parallel.
  - ASSEMBLE: Assembles input frames. Uses input frames. Derives eye and
    viewport from output frames associated with input frames. By
    default, the task executes the assembly unordered and potentially
    pipelined or in parallel. Frames with COLOR and DEPTH images use by
    default a z-based assembly.
    ? Overlapping frames with alpha color data use by default an
    unordered blending assembly. Otherwise a tile-based assembly is
    used. ?
    Ordering or CPU compositing is application-specific, and has to be
    implemented by the application by using a custom callback.
  - SWAP: Is implicitely the last task on all double-buffered
    _windows_. Will not be exposed in the API and config file atm.

   Attributes

    Attributes are inherited, that is, if they are not defined they are
    defined by the parent. If they are defined, they are often expressed
    relative to the parent. The following attributes are defined:

     - task: non-inherited bitwise combination of tasks (see
       above). DRAW is executed only on leaf compounds. Defaults to
       [ CLEAR CULL DRAW ASSEMBLE READBACK ]
     - viewport: 2D fractional viewport wrt to the parent in screen
       space. Default is [0 0 1 1], i.e., the full viewport.
     - range: 1D, application-dependent range of the data to be
       rendered. Relative to the parent's range. Default is [0 1], i.e.,
       the full database range.
     - eye: Bitwise combination of the eye views (and quad-stereo
       buffer) to be rendered. Absolute, but inherited. Initially, left,
       right and cyclop are defined. Support for autostereo displays may
       introduce new 'eyes' and/or attributes. Default is cyclop.
     - period/phase: Frames to be rendered (DPlex). Absolute, but
       inherited. Default is period 1, phase 0. All channels on the same
       pipe should/must(?) have the same period and phase. Phase must be
       smaller than period.
     - format: Bitwise combination of color, depth and stencil. Defines
       which images are read during output. Default is color.
     - attributes {
           (color,depth,stencil)x(format,type): Format and type (as in
               OpenGL) to be used for reading or writing the corresponding
               images. Default is hardware-dependent, typically
               GL_RGBA/GL_UNSIGNED_INT, GL_DEPTH_COMPONENT/GL_FLOAT,
               GL_STENCIL_INDEX/???
       }

   Input and Output

    Certain tasks generate input and output. Right now, this can be
    queues for culling and frames for gathering.

    Output frames use viewport, eye, period and phase attributes, which
    are relative to the compound viewport. Input frames use the
    viewport, period and phase attributes, which are relative to the
    corresponding output frame viewport. The eye attributes from the
    output frame are used.

    TODO: Queues and culling semantics


 Restrictions
 ------------

   The cull task, queues, DPlex and subpixel decomposition are not fully
   described. They will be designed further and implemented
   later. Stencil images will be implemented later.


 File Format
 -----------

   compound
   {
       channel "channel-name"
       <frustum-spec>
       format [ COLOR DEPTH STENCIL ]
       task   [ CLEAR CULL DRAW (compounds) ASSEMBLE READBACK ]

       attributes
       {
           color, depth, stencil
           {
               format <GL_enum>
               type   <GL_enum>
           }
       }
       viewport [ x y w h ]
       range    [ start end ]
       eye      [ CYCLOP LEFT RIGHT ]
       period   <int>
       phase    <int>

       (inputframe|outputframe) // 0-n times, executed after draw, first input
       {
           format [ COLOR DEPTH STENCIL ]
           name    "frame-name" // defaults to "frame.<channel-name>"
           viewport [ x y w h ]
           eye      [ cyclop left right ]
       }

       (inputqueue|outputqueue)    {...}
       swapbarrier  { name "barrier-name" } // last task per compound
   }
       
========================================================================
                          Example Config Files
========================================================================

   2-channel DB compound:

    compound {
        channel "destination"
        format [ COLOR DEPTH ]
        
        compound {
            channel "buffer"
            range [ 0 .5 ]
            outputframe {}
        }
        compound
        {
            task [ CULL DRAW ]
            range [ .5 1 ] 
        }
        inputframe { name "frame.buffer" }
    }
------------------------------------------------------------------------

   2-channel 2D ASYNC compound, latency should be >=1 :

    compound {
        channel "destination"
        
        compound {
            channel "buffer"
            viewport [ 0 0 .5 1 ]
            outputframe {}
        }

        compound { task [ ASSEMBLE ]  inputframe { name "frame.buffer" }}
        compound { task [ CULL DRAW ] viewport [ .5 0 .5 1 ] }
    }
------------------------------------------------------------------------
   
   2-channel SYNC compound:

    compound {
        compound {
            channel "channel1"
            wall {}
            swapbarrier { name "barrier" }
        }
        compound {
            channel "channel2"
            wall {}
            swapbarrier { name "barrier" }
        }
    }

------------------------------------------------------------------------
   
   2:3-channel DPlex compound:

    compound {
        channel "destination"
        
        compound {
            channel "buffer1"
            period 2
            phase  0

            outputframe {}
        }
        compound {
            channel "buffer2"
            period 2
            phase  1

            outputframe {}
        }

        compound {
            task  [ ASSEMBLE ]
            inputframe { frame "frame.buffer1" }
            inputframe { frame "frame.buffer2" }
        }
    }
------------------------------------------------------------------------

   3-channel DB compound, direct send assembly

    compound {
        channel "dest"
        format [ COLOR DEPTH ]
        
        compound {
            channel "buffer1"
            range [ 0 .3333 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ 0 0   1 .33 ] frame "frame1.buffer1" }
                outputframe { viewport [ 0 .33 1 .33 ] frame "frame2.buffer1" }
            }
            inputframe { frame "frame2.buffer2" }
            inputframe { frame "frame2.dest" }
            outputframe { format [ COLOR ] viewport [ 0 .66 1 .34 ] }
        }
        compound {
            channel "buffer2"
            range [ .3333 .6666 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [0  0   1 .33 ] frame "frame1.buffer2" }
                outputframe { viewport [0  .66 1 .34 ] frame "frame2.buffer2" }
            }
            inputframe { frame "frame2.buffer1" }
            inputframe { frame "frame1.dest" }
            outputframe { format [ COLOR ] viewport [ 0 .33 1 .33 ] }
        }
        compound {
            channel "dest"
            task    [ CULL DRAW ]
            range   [ .6666 1 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ 0 .33 1 .33 ] frame "frame1.dest" }
                outputframe { viewport [ 0 .66 1 .34 ] frame "frame2.dest" }
            }
        }

        inputframe { frame "frame1.buffer1" }
        inputframe { frame "frame1.buffer2" }
        inputframe { frame "frame.buffer1" }
        inputframe { frame "frame.buffer2" }
    }
------------------------------------------------------------------------

   4-channel DB compound, binary swap assembly

    compound {
        channel "dest"
        format [ COLOR DEPTH ]
        
        compound {
            channel "buffer1"
            range [ 0 .25 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ 0 0 1 .5 ] frame "frame1.buffer1" } 
            }
            compound {
                task [ ASSEMBLE READBACK ]
                inputframe{ frame "frame1.buffer2" }
                outputframe { viewport [ 0 .5 1 .25 ] frame "frame2.buffer1" }
            }
            inputframe{ frame "frame2.buffer3" }
            outputframe { format [ COLOR ] viewport [ 0 .75 1 .25 ] } 
        }
        compound {
            channel "buffer2"
            range [ .25 .5 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ .5 0 .5 1 ] frame "frame1.buffer2" } 
            }
            compound {
                task [ ASSEMBLE READBACK ]
                inputframe{ frame "frame1.buffer1" }
                outputframe { viewport [ 0 0 1 .25 ] frame "frame2.buffer2" } 
            }
            inputframe{ frame "frame2.dest" }
            outputframe { format [ COLOR ] viewport [ 0 .25 1 .25 ] }
        }
        compound {
            channel "buffer3"
            range [ .5 .75 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ 0 0 1 .5 ] frame "frame1.buffer3" } 
            }
            compound {
                task [ ASSEMBLE READBACK ]
                inputframe{ frame "frame1.dest" }
                outputframe { viewport [ 0 .75 1 .25 ] frame "frame2.buffer3" }
            }
            inputframe{ frame "frame2.buffer1" }
            outputframe { format [ COLOR ] viewport [ 0 .5 1 .25 ] }
            
        }
        compound {
            channel "dest"
            task    [ CULL DRAW ]
            range [ .75 1 ]

            compound {
                task [ READBACK ]
                outputframe { viewport [ .5 0 .5 1 ] frame "frame1.dest" } 
            }
            compound {
                task [ ASSEMBLE READBACK ]
                inputframe{ frame "frame1.buffer2" }
                outputframe { viewport [ 0 .25 1 .25 ] frame "frame2.dest" } 
            }
        }

        inputframe { frame "frame2.buffer2" }
        inputframe { frame "frame.buffer1" }
        inputframe { frame "frame.buffer2" }
        inputframe { frame "frame.buffer3" }
    }
