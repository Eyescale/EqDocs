
                          Distributed Objects
                          ===================

                       Author: eilemann@gmail.com
                       Date:   10. July 2006


Overview
--------

 Equalizer provides some facilities to ease the distribution of an
 application. The central piece is the Object base class, from which
 networked objects are derived.

Classification
--------------

 Equalizer knows different types of objects: unversioned and versioned
 objects. The implementation of unversioned objects is straight-forward and
 requires the application to implement Object::getInstanceData() and the
 appropriate construction in Session::instanciateObject().

 The implementation of versioned objects becomes quickly more complex
 when trying to find the right balance between memory footprint, network
 bandwidth and CPU utilisation. This complexity lies mostly in the
 handling and instantiation of 'old' versions.

Versioned Objects
-----------------

 Versioned objects have to implement in addition Object::pack() and
 Object::unpack(). These methods create or apply a diff from the last
 version. In order to keep track of old versions, two fundamental
 approaches can be taken. Both approaches have to keep a copy of all
 'patches' from the oldest to the newest version.
 The first approach creates a proxy object which represents the oldest
 available version. When a new instance of the object is created, the
 proxy object's instance data and all patches are sent to the
 instanciating node. The receiver instanciates the object and unpacks the
 patches as requested. This approach minimises memory usage while
 requiring more network bandwidth and CPU cycles.
 The second approach does not create a proxy object, but keeps an
 instance data for each version in addition to the version patches. When
 an object is instanciated, the _requested_ version's instance data and
 all following patches are send to the requestor. This approach minimises
 network traffic and CPU load, but requires more memory. For some objects
 and versions, the pack'ed data is equivivalent to the instance
 data. In this case, the memory consumption can be as low as for the
 other approach.
 Both approaches need a mechanism to obsolete old versions. Depending on
 the use case, this may be automatically done by Object::commit, or
 explicitly by the application. At least one base version has to be kept
 for the checkout. The automatic obsoletion can be configured to keep a
 fixed number of versions, or to keep the versions for a fixed number of
 commits (not each commit may generate a new version). By default, only
 the last version is kept.

Multiple Instances
------------------

 There are certain use-cases within Equalizer when two different
 versions of the same objects have to be instantiated on the same node.
 One example is the usage of the same per-frame data by two different
 pipe threads on the same node, where each pipe thread renders a
 different frame.

 Therefore, an object command sent to a node may affect more then one
 instance. The following implementations are conceivable:

 - Create a unique instance ID, so that the objects can be addressed
   individually. Problem: One command will be sent multiple times.

 - Extend the CommandResult to let the implementation decide to
   propagate the command to other instances or to declare the command
   handled. Problem: May be hard to decide on the receiver?

 -> Second approach seems to be the right one.
 
 Another issue is the instanciation and referentiation method of
 objects. The default approach is to access the instantiated objects per
 identifier, which works if there is only one instance. This concept can
 be extended to have one instance per thread.


see src/lib/net/object.h for implemented API

Unimplemented API:

  void event(); // to implement auto-sync

  void     commitNB();      // non-blocking commit
  uint64_t completeCommit()
