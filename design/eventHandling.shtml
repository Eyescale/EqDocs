#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Event Handling

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
</p>

<h2>X11/glX Implementation</h2>
<div class="float_right">
  <a href="documents/design/images/eventHandling.png">
    <img src="documents/design/images/eventHandling-small.png" 
         alt="Event Handling Sequence Diagram"/></a>
  <div class="label">Event Handling Call Flow</div>
</div>
<p>
  Equalizer implements a basic event handling mechanism, simplifying the
  development of small-sized to medium-sized applications. Complex applications
  will implement their own event handling, and disable the event handling in
  Equalizer.
</p><p>
  Equalizer uses a single, separate event thread for all pipes and windows on
  a given node. The event thread registers for events of all windows, and
  asynchronously processes events to allow both event-driven and
  continous-update execution.
</p><p>
</p><p> When the event thread receives an event from the window system, it finds
  the associated <code>eq::Window</code> and creates a
  generic <code>WindowEvent</code> from the system-specific event. The generic
  event contains the system-specific event, i.e., the X11 Event, and is passed
  to <code>Window::processEvent</code>. The default implementation
  of <code>Window::processEvent</code> transform the window event into
  a <code>ConfigEvent</code>, which is sent to the application thread
  using <code>Config::sendEvent</code>. Since the config event is potentially
  transferred to another node, it no longer contains the system-specific event.
</p><p>
  At the end of the frame, <code>Config::endFrame</code>
  calls <code>Config::processEvent</code> on each queued event. The default
  implementation is empty, the <code>eqPly</code> example implements some basic
  mouse and keyboard interaction.
</p><p>
  The exit phase is not shown in the above sequence diagram for simplicity. The
  windows and pipes are removed in the reverse order. When no entities are left
  to be handled, the event thread automatically terminates. It will restart upon
  the new initialisation of a pipe.
</p>

<h2>Win32 Implementation</h2>
<p>
  The Windows implementation of event handling differs from the X11 version in
  that no separate event thread is used. Instead, Windows messages are received
  by the pipe thread responsible for the window, and passed through the same
  processing chain as X11 events. The application event processing code is
  system-agnostic.
</p>

<h2>API</h2>
<!-- /* --><pre>
  virtual bool Window::processEvent( const WindowEvent& event );
  void Config::sendEvent( ConfigEvent& event );

  const ConfigEvent* Config::nextEvent();
  bool Config::checkEvent() const;
  virtual void Config::handleEvents();
  virtual bool Config::handleEvent( const ConfigEvent* event );

  class WindowEvent;
  struct ConfigEvent;
</pre><!-- */ -->

<h2>Open Issues</h2>
<p>
  Implement and document CGL event handling
</p>

#include "footer.shtml"
<!-- $Id$ -->
