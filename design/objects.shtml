#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Distributed Objects

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
</p>

<p>
  Equalizer provides facilities to ease the data distribution of an
  application. The central piece is the <code>eqNet::Object</code> base class,
  from which distributed objects are derived.
</p>

<h2>Classification</h2>
<p>
  Equalizer knows different types of objects: unversioned and versioned
  objects.
</p><p>
  Unversioned objects can be instanciated on multiple nodes. Upon instanciation,
  the data from the master version is replicated to the 'slave' node. They are
  typically used for static data.
</p><p> 
  Versioned objects work like a simplified version control system. One
  master copy of the object creates a new version whenever the application
  calls <code>Object::commit</code>. This version is pushed to all subscribers,
  that is, to all nodes which have mapped the object. The version data is queued
  on the object, and will be applied when the application
  calls <code>Object::sync</code> to synchronize a specific version, or the head
  version.
</p><p>
  A simplified type of versioned objects are objects where the instance data is
  equal to the delta data, i.e., objects which sync their full data on each
  commit.
</p>

<h2>Unversioned Objects</h2>
<p>
  The implementation of unversioned objects is straight-forward and requires the
  application to either declare its distributed data using
  <code>Object::setInstanceData</code> or to implement 
  <code>Object::getInstanceData</code>. For instanciation, the appropriate
  construction in <code>Session::instanciateObject</code> has to be implemented.
</p>

<h2>Versioned Objects</h2>
<p>
  Versioned objects have to implement, in addition to unversioned objects, the
  methods <code>Object::pack</code> and <code>Object::unpack</code> to create or
  apply a diff from the last version. Alternatively they can declare the
  location of the data using <code>Object::setDeltaData</code> on both the
  master and slave instances.
</p>

<h2>Implementation</h2>
<pre>
class Object
{
public:
    uint32_t commit();
    uint32_t sync();
    uint32_t getVersion();
    uint32_t getHeadVersion();

protected:
    setInstanceData(...);
    setDeltaData(...);

private:
    ObjectCM* _cm;
};

class ObjectCM
{
public:
    ObjectCM( Object* managed );

}

class StaticMasterCM;
class StaticSlaveCM;
class FullMasterCM;
class FullSlaveCM;
class DeltaMasterCM;
class DeltaSlaveCM;

</pre>
<p>
  The implementation of versioned objects becomes quickly more complex
  when trying to find the right balance between memory footprint, network
  bandwidth and CPU utilisation. This complexity lies mostly in the
  handling and instantiation of 'old' versions.
</p><p>
  In order to keep track
  of old versions, two fundamental approaches can be taken. Both approaches have
  to keep a copy of all 'patches' from the oldest to the newest version.
</p><p> 
  The first approach creates a proxy object which represents the oldest
  available version. When a new instance of the object is created, the proxy
  object's instance data and all patches are sent to the instanciating node. The
  receiver instanciates the object and unpacks the patches as requested. This
  approach minimises memory usage while requiring more network bandwidth and CPU
  cycles.
</p><p>
  The second approach does not create a proxy object, but keeps an
  instance data for each version, in addition to the version patches. When an
  object is instanciated, the _requested_ version's instance data and all
  following patches are send to the requestor. This approach minimises network
  traffic and CPU load, but requires more memory. For some objects and versions,
  the pack'ed data is equivivalent to the instance data. In this case, the
  memory consumption can be as low as for the other approach.
</p><p> 
  Both approaches need a mechanism to obsolete old versions. Depending on
  the use case, this may be automatically done in <code>Object::commit</code>,
  or explicitly by the application. At least one base version has to be kept for
  the checkout. The automatic obsoletion can be configured to keep a fixed
  number of versions, or to keep the versions for a fixed number of commits (not
  each commit may generate a new version). By default, only the last version is
  kept.
</p>

<h3>Multiple Instances</h3>
<p>
  There are certain use cases within Equalizer when two different versions of
  the same objects have to be instantiated on the same node. One example is the
  usage of the same per-frame data by two different pipe threads on the same
  node, where each pipe thread renders a different frame.
</p><p>
  Therefore, an object command sent to a node may affect more then one
  instance. The following implementations are possible:
  <ul>
    <li>Create a unique instance ID, so that the objects can be addressed
      individually. Problem: One command will be sent multiple times.</li>
    <li>Extend the CommandResult to let the implementation decide to
      propagate the command to other instances or to declare the command
      handled. Problem: May be hard to decide on the receiver?</li>
  </ul>
  -> Second approach seems to be the right one.
</p><p>
  Another issue is the instanciation and referentiation method of
  objects. The default approach is to access the instantiated objects per
  identifier, which works if there is only one instance. This concept can be
  extended to have one instance per thread.
</p>

<h2>Open Issues</h2>
<pre>
  void event(); // to implement auto-sync

  void     commitNB();      // non-blocking commit
  uint64_t completeCommit()
</pre>

#include "footer.shtml"
<!-- $Id$ -->
