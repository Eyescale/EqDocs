#define S_DOCUMENTATION
#define S_DOCUMENTATION_DEVELOPER
#define PAGE Documentation
#define SUBPAGE Developer
#define TITLE Distributed Objects

#include "header.shtml"

<p>
Author: <a href="mailto:eilemann@gmail.com">eilemann@gmail.com</a><br/>
</p>

<p>
  Equalizer provides facilities to ease the data distribution of an
  application. The central piece is the <code>eqNet::Object</code> base class,
  from which distributed objects are derived. Objects become accessable by
  making them known to a session. The example code shipped with Equalizer
  contains examples of distributed objects.
</p>

<h2>Classification</h2>
<p>
  Equalizer can manage static and versioned objects.
</p><p>
  Static objects can be instanciated on multiple nodes. Upon instanciation,
  the data from the master version is replicated to the 'slave' node. Static
  objects do not retain object data, since this data is assumed to be
  immutable.
</p><p> 
  Versioned objects work like a simplified version control system. One
  master copy of the object creates a new version whenever the application
  calls <code>Object::commit</code>. This version is pushed to all subscribers,
  that is, to all nodes which have mapped the object. The version data is queued
  on the object, and will be applied when the application
  calls <code>Object::sync</code> to synchronize a specific version, or the head
  version.
</p><p>
  A simplified type of versioned objects are objects where the instance data is
  equal to the delta data, i.e., objects which sync their full data on each
  commit.
</p>

<h2>Object Mapping</h2>
<p>
  To make objects distributable, they have to be known by the session. During
  this process the type of object is determined.
</p><p> 
  The master instance of an object is registered
  using <code>Session::registerObject</code>. Upon registration, a
  session-unique identifier is assigned, which can be used to map slave
  instances using <code>Session::mapObject</code>. Mapped slave instance are
  instanciated with the oldest known version from the master instance, and can
  be synchronized to the head version using <code>Object::sync</code>.
</p><p>
  Additionally, the object identifier can be used to send
  an <code>ObjectPacket</code> to another node. Each object instance has a
  node-unique instance identifier to address single instances of an object on a
  remote node.
</p>

<h2>Static Objects</h2>
<p>
  The implementation of unversioned objects is straight-forward and requires the
  application to either declare the distributed data using
  <code>Object::setInstanceData</code> or to implement 
  <code>Object::getInstanceData</code>.
</p>

<h2>Versioned Objects</h2>
<p>
  Versioned objects override the method <code>Object::isStatic</code> to return
  <code>false</code>. They have to implement, in addition to unversioned
  objects, the methods <code>Object::pack</code> and <code>Object::unpack</code>
  to create or apply a diff from the last version. Alternatively they can
  declare the location of the data using <code>Object::setDeltaData</code> on
  both the master and slave instances.
</p><p>
  Objects with the same instance and delta data only distribute instance data
  for each new version, and do not have to implement pack and unpack.
</p>

<h2>Implementation</h2>
<p>
  Each object has a change manager, which depends on the type of the object and
  its master/slave status. Equalizer implements a change manager for static
  objects, versioned objects with delta data and versioned objects with only
  instance data. Externalizing the implementation of change handling allows for
  optimisations in the implementation and the memory usage for storing the
  version data.
</p>

<h2>Open Issues</h2>
<p>
  Document <code>Session::attachObject</code> for unmanaged
  objects. Document object version obsoletion.
</p>

#include "footer.shtml"
<!-- $Id$ -->
